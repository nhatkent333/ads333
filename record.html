<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-t" />
  <title>Record Chrome Tab - Highest Quality</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 900px; margin: auto; }
    video { width: 100%; background: #000; margin-top: 10px; border: 1px solid #ccc; }
    button { padding: 8px 14px; margin: 4px; font-size: 14px; cursor: pointer; }
    button:disabled { cursor: not-allowed; opacity: 0.6; }
    p { font-size: 16px; }
    #status { font-weight: bold; }
  </style>
</head>
<body>
  <h2>Ghi l·∫°i Chrome Tab (Ch·∫•t l∆∞·ª£ng Cao Nh·∫•t)</h2>
  <button id="btnShare">Chia s·∫ª tab</button>
  <button id="btnStart" disabled>B·∫Øt ƒë·∫ßu ghi</button>
  <button id="btnStop" disabled>D·ª´ng ghi</button>
  <button id="btnDownload" disabled>T·∫£i video</button>
  <p>Tr·∫°ng th√°i: <span id="status">ch·ªù...</span></p>

  <video id="preview" autoplay playsinline muted></video>

  <script>
    const btnShare = document.getElementById("btnShare");
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnDownload = document.getElementById("btnDownload");
    const statusEl = document.getElementById("status");
    const preview = document.getElementById("preview");

    let stream, mediaRecorder, chunks = [], recordedBlob;

    btnShare.onclick = async () => {
      try {
        stream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            cursor: "never",
            width: { ideal: 1920, max: 1920 }, // ∆Øu ti√™n v√† gi·ªõi h·∫°n ·ªü 1920
            height: { ideal: 1080, max: 1080 },// ∆Øu ti√™n v√† gi·ªõi h·∫°n ·ªü 1080
            frameRate: { ideal: 60 }
          },
          // ‚úÖ C·∫£i thi·ªán ch·∫•t l∆∞·ª£ng √¢m thanh
          audio: {
            sampleRate: 48000,
            channelCount: 2,
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
          }
        });

        preview.srcObject = stream;
        btnStart.disabled = false;
        btnShare.disabled = true;
        setStatus("s·∫µn s√†ng ghi");
      } catch (err) {
        console.error(err);
        setStatus("l·ªói: " + err.message);
      }
    };

    btnStart.onclick = () => {
      chunks = [];
      
      // ‚úÖ T·ª± ƒë·ªông ch·ªçn codec v√† bitrate t·ªët nh·∫•t
      const options = getBestRecorderOptions();
      console.log("S·ª≠ d·ª•ng c√†i ƒë·∫∑t ghi:", options);
      
      mediaRecorder = new MediaRecorder(stream, options);

      mediaRecorder.ondataavailable = e => e.data.size && chunks.push(e.data);
      
      mediaRecorder.onstop = () => {
        recordedBlob = new Blob(chunks, { type: options.mimeType });
        btnDownload.disabled = false;
        setStatus("ƒë√£ d·ª´ng");
      };

      mediaRecorder.start(); // Ghi li√™n t·ª•c thay v√¨ c·∫Øt m·ªói gi√¢y
      btnStart.disabled = true;
      btnStop.disabled = false;
      setStatus("ƒëang ghi...");
    };

    btnStop.onclick = () => {
      mediaRecorder.stop();
      btnStop.disabled = true;
      btnStart.disabled = false;
    };

    btnDownload.onclick = () => {
      // ‚úÖ T√™n file ƒë·ªông theo th·ªùi gian
      const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, "");
      const fileName = `recording-${timestamp}.webm`;
      
      const url = URL.createObjectURL(recordedBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    };

    function setStatus(s) { statusEl.textContent = s; }

    function getBestRecorderOptions() {
      // ‚úÖ ∆Øu ti√™n codec AV1 v√¨ hi·ªáu qu·∫£ h∆°n, n·∫øu kh√¥ng c√≥ th√¨ d√πng VP9 bitrate si√™u cao
      const av1MimeType = 'video/webm;codecs=av01.0.05M.08,opus';
      if (MediaRecorder.isTypeSupported(av1MimeType)) {
        return {
          mimeType: av1MimeType,
          videoBitsPerSecond: 15000000, // 15 Mbps cho AV1 l√† r·∫•t cao
        };
      }
      
      // L·ª±a ch·ªçn d·ª± ph√≤ng l√† VP9 v·ªõi bitrate r·∫•t cao
      return {
        mimeType: "video/webm;codecs=vp9,opus",
        videoBitsPerSecond: 25000000, // üöÄ TƒÉng m·∫°nh bitrate l√™n 25 Mbps
      };
    }
  </script>
</body>
</html>
